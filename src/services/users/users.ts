/**
 * Generated by orval v6.1.1 üç∫
 * Do not edit manually.
 * Nightborn Dev Exercise API
 * Swagger for Nightborn-dev-exercise-back-end project.

Schemes: [http, https]
 * OpenAPI spec version: 1.0.0
 */
import {
  useQuery,
  useMutation,
  UseQueryOptions,
  UseMutationOptions
} from 'react-query'
import type {
  User,
  UpdateUserInput
} from '../../types/dtos'
import { customInstance } from '.././config'

type AsyncReturnType<
T extends (...args: any) => Promise<any>
> = T extends (...args: any) => Promise<infer R> ? R : any;


export const getAll = (
    
 ) => {
      return customInstance<User[]>(
      {url: `/api/v1/users`, method: 'get'
    },
      );
    }
  

export const getGetAllQueryKey = () => [`/api/v1/users`];

    
export const useGetAll = <TData = AsyncReturnType<typeof getAll>, TError = void>(
  options?: { query?:UseQueryOptions<AsyncReturnType<typeof getAll>, TError, TData>, }

  ) => {

  const {query: queryOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getGetAllQueryKey();
  const queryFn = () => getAll();

  const query = useQuery<AsyncReturnType<typeof queryFn>, TError, TData>(queryKey, queryFn, queryOptions)

  return {
    queryKey,
    ...query
  }
}

export const addUser = (
    user: User,
 ) => {
      return customInstance<User>(
      {url: `/api/v1/users`, method: 'post',
      data: user
    },
      );
    }
  


    export const useAddUser = <TError = void,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof addUser>, TError,{data: User}, TContext>, }
) => {
      const {mutation: mutationOptions} = options || {}

      return useMutation<AsyncReturnType<typeof addUser>, TError, {data: User}, TContext>((props) => {
        const {data} = props || {};

        return  addUser(data,)
      }, mutationOptions)
    }
    export const getUserById = (
    id: string,
 ) => {
      return customInstance<User>(
      {url: `/api/v1/users/${id}`, method: 'get'
    },
      );
    }
  

export const getGetUserByIdQueryKey = (id: string,) => [`/api/v1/users/${id}`];

    
export const useGetUserById = <TData = AsyncReturnType<typeof getUserById>, TError = void>(
 id: string, options?: { query?:UseQueryOptions<AsyncReturnType<typeof getUserById>, TError, TData>, }

  ) => {

  const {query: queryOptions} = options || {}

  const queryKey = queryOptions?.queryKey ?? getGetUserByIdQueryKey(id);
  const queryFn = () => getUserById(id, );

  const query = useQuery<AsyncReturnType<typeof queryFn>, TError, TData>(queryKey, queryFn, {enabled: !!(id), ...queryOptions})

  return {
    queryKey,
    ...query
  }
}

export const updateUser = (
    id: string,
    updateUserInput: UpdateUserInput,
 ) => {
      return customInstance<User>(
      {url: `/api/v1/users/${id}`, method: 'patch',
      data: updateUserInput
    },
      );
    }
  


    export const useUpdateUser = <TError = void,
    
    TContext = unknown>(options?: { mutation?:UseMutationOptions<AsyncReturnType<typeof updateUser>, TError,{id: string;data: UpdateUserInput}, TContext>, }
) => {
      const {mutation: mutationOptions} = options || {}

      return useMutation<AsyncReturnType<typeof updateUser>, TError, {id: string;data: UpdateUserInput}, TContext>((props) => {
        const {id,data} = props || {};

        return  updateUser(id,data,)
      }, mutationOptions)
    }
    